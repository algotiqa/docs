= Tiq: the Algotiqa's scripting language
Andrea Carboni (andrea.carboni71@gmail.com)
:toc:

== Data types

=== Basic types

|===
|Type | Description

|int
|64 bit signed integer

|real
|64 bit floating point number

|bool
|Boolean value

|string
|Unicode string

|time
|Time of the day in the hh:mm format with hh=0..23 and mm=0..59

|date
|Generic date, in the YYYY-MM-DD format

|timeseries
|Series of datapoints equally spaced in time. Used to represent prices

|enum
|Enumeration of element

|list
|Collection of ordered objects

|map
|Association between keys and values

|class
|Class object defining a complex structure

|error
|This is an alias for a string type and defines an error condition
|===

Examples:

[source]
----
a = 5
b = "test"
c = false

//--- All together

a, b, c = 5, "test", false
----

=== Nulls

A *null* is a special value.

On a boolean condition, a null value is considered as *false*.

=== Containers

Containers are types that contain elements inside them. These elements can be ordered (lists) or unordered (maps, sets)

==== Lists

Represents a list of elements of any type (basic, container, class or null).

Examples:

.Example
[source]
----
a = list of (int)
a = [ 1, 2, 3, 4, 5 ]
a.add(5)
a.add(null)   ??????
a.size()
a.clear()
a.deleteAt(index)
a.merge(b)
a list(int)
v = a[index]
a[index] = v
size(a)
append(a,v)
delete(a, index)
clear(a)
zero() : set all values to zero (0, 0.0, false, "", null????)


----

==== Maps

Allows to store (key,value) pairs.
- Keys can be string or int
- Values can be of any type (basic, container, class or null)

Examples:

.Example
[source]
----
a = map of string,int
a.get(key)
a.set(key,value)
a.contains(key)
a.size()
a.clear()
a.delete(key)
a.merge(b)
a map(string,int)
v,ok = a[key]
a[key] = value
size(a)
clear(a)
delete(a, key)

----

==== Sets

=== Enums

[source]
----
enum Color {
    Red(), Green(), Blue()
}

enum Level {
    Info("info"), Warning("warn"), Error("err")
}

enum HttpCode {
    NotFound(404), Forbidden(403)
}
----

=== Classes

== Conditions

[source]
----
if <condition> { statement* }
[else if <condition> { statement* }]*
[else { statement* }]
----

[source]
----
switch myVar {
 case <value>:
    statement*
 case <value>:
    statement*
 default:
    statement*
}
----

== Loops

=== For loops

[source]
----
for e in listObject {
    e.index
    e.value
    e.isLast
}
----

[source]
----
for e in mapObject {
    e.key
    e.value
    e.isLast
}
----

[source]
----
for i=0; i<5; i++ {
}

----

=== While

[source]
----
while <condition> {
}
----

== Functions and methods

Parameters are passed by reference (also for basic types?)

== Structure

=== File structure

Given a folder (i.e. the strategy's code folder), all *.bfl files into these folders are loaded.
Subfolders are scan recursively.

Each source file will have the following structure:

- Class definitions
- Variable definitions
- Function definitions
- Strategy definition
- Interface definition


=== Packages

Each strategy code will land into the *default* package.

Users will have the possibility to create other packages. If a user will use an existing system package
the user's package will have priority when resolving functions. This allows users to patch or improve the
system packages.

There will be the following system packages: os, io, math. An administrator will have the possibility
to install new versions of these packages.

== Runtime environment

=== Runtime variables

The following variables will be available to a strategy:

- open, close, high, low: time series indicating the current price values
- openS, closeS, highS, lowS: time series for session related values (typically 1 value per day)

==== The *bar* object

|===
|Property |Description

|index
|Starts from 0 and represents the number of bars that has been processed

|open
|

|close
|

|high
|

|low
|

|openS
|

|closeS
|

|highS
|

|lowS
|

|isSessionStarted
|Indicates if this bar is the first bar of a new session

|isSessionEnded
|Indicates if this bar is the last bar of the session
|===

==== The *trade* object

Represents the current trade and contains the following properties and methods:

|===
| Property | Description

| position
| Can be positive (for long) or negative (for short). The quantity represents the number of contracts

| isLong
|

| isShort
|

| isFlat
|

| profit
| Current profit of the trade. Can be positive (gain) or negative (loss)

| maxProfit
| Max profit achieved by the trade
|===

Methods:

close()::
Closes the open position, buying or selling all contracts


=== Events

onTradeEnter()::
called when a new trade has started

onTradeExit()::
called when exiting from a trade. Can be used to export trades

onSessionStart()::
x
onSessionEnd()::
x

== Future

- Possibility to apply a transformation on input prices

== Assembly

|===
| Instruction | Description

| add_i ri, rj, rk
| Adds 2 integers

| sub_i ri, rj, rk
|

| mult_i ri, rj, rk
|

| add_f ri, rj, rk
|

| sub_f ri, rj, rk
|

| mult_f ri, rj, rk
|

| lesst_i ri, rj, rk
| Compares ri and rj. Result (less than) is put into rk (bool)

| equ_i ri, rj, rk
|

| lesst_f ri, rj, rk
| Compares ri and rj. Result (less than) is put into rk (bool)

| equ_f ri, rj, rk
|

| conv_if ri, rj
| Converts ri into an integer, storing the result into rj (float)

| const_i num, ri
| Loads the integer constant num into ri

| const_s string, ri
| Loads a string into ri (ri = constPool[index-of-string])

| const_f value, ri
| Loads a float into ri ( ri = constPool[index-of-value] )

| call f(), ri, rj
| Calls function f (from the constPool). Ri indicates from which register the parameters are stored (these are from ri to ri+n-1 where n=num of params). Rj indicates from which register the results will be stored. Creates a new StackFrame and adds it to the call stack

| ret ri
| Returns from a function call. Returns values are stored from ri ti ri+m-1 where m=num of results. Pops a StackFrame from the stack

| jmp a
| Jumps to address a

| jmp_t ri, a
| Jumps to a if ri=true

| jmp_f ri, a
| Jumps to a if ri=false

| gload a, ri
| Loads globals[a] into ri

| gstore ri, a
| Stores ri into globals[a]

| struct ri, n
| ri = new struct with n field slots

| print ri
| Prints ri to standard out

| halt
| Halts program execution (exits from the virtual machine)

|===